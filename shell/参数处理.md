#  refer
	http://www.jb51.net/article/48686.htm

# 处理方式
	例如：./test.sh -f config.conf -v --prefix=/home
## 手工处理
	*    $0 ： ./test.sh,即命令本身，相当于c/c++中的argv[0]
	*    $1 ： -f,第一个参数.
	*    $2 ： config.conf
	*    $3, $4 ... ：类推。
	*    $#  参数的个数，不包括命令本身，上例中$#为4.
	*    $@ ：参数本身的列表，也不包括命令本身，如上例为 -f config.conf -v --prefix=/home
	*    $* ：和$@相同，但"$*" 和 "$@"(加引号)并不同，"$*"将所有的参数解释成一个字符串，而"$@"是一个参数数组。
	#!/bin/bash
	for arg in "$*"
	do
	  echo $arg
	done
	for arg in "$@"
	do
	 echo $arg
	done
## getopts
	不支持长选项
	#!/bin/bash
	while getopts "a:bc" arg #选项后面的冒号表示该选项需要参数
	do
	        case $arg in
	             a)
	                echo "a's arg:$optarg" #参数存在$optarg中
	
	             b)
	                echo "b"
	
	             c)
	                echo "c"
	
	             ?)  #当有不认识的选项的时候arg为?
	            echo "unkonw argument"
	        exit 1
	
	        esac
	done
## getopt
	要点:
	1. getopt 用法
	语法：getopt [options] [--] optstring parameters
	例如：getopt ab:cd -a -b he free cat 
	输出：-a -b he -- free cat
	            getopt 根据 ab:cd 将选项和参数 -a -b he free cat  解析为如下格式：
	            -a -b he -- free cat
	             其中 -- 将选项与非选项参数分开 free 和 cat 就时非选项参数
	2. set -- 
	-- Do not change any of the flags; useful in setting $1 to -.
	set --  主要是影响特殊变量$1 $2 等，其实在上面的脚本中就是将$1 $2 等参数变量重新组合
	例如：
	set -- a b c 
	shell中的特殊位置变量$1 为a $2 为 b $3 为 c
	3.如上脚本为build.sh 用法如下：
	./build.sh -a -c -d -e dog
	./build.sh -acde  dog
	上面两个命令执行结果相同。